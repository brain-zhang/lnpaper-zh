## 3.Bidirectional Payment Channels
## 3. 双向支付通道

Micropayment channels permit a simple defdeerral of a transaction state to be broadcast at a later time. The contracts are enforced by creating a responsibility for one party to broadcast transactions before or after certain dates. If the blockchain is a decentralized timestamping system, it is possible to use clocks as a component of decentralized consensus[5] to determine data validity, as well as present states as a method to order events[6].

> 微支付通道允许将一笔交易简单的延迟到以后广播。这些合约的执行方式是：让一方必须在特定日期之前或之后广播交易。如果区块链是一个去中心化的时间戳系统，那么可以使用时间戳作为去中心化共识的一个部分来确定数据的有效性，这相当于解决了当前状态的时序同步问题[6]。

By creating timeframes where certain states can be broadcast and later invalidated, it is possible to create complex contracts using bitcoin transaction scripts. There has been prior work for Hub-and-Spoke Micro- payment Channels[7][8][9] (and trusted payment channel networks[10][11]) looking at building a hub-and-spoke network today. However, Lightning Network’s bidirectional micropayment channel requires the malleability soft- fork described in Appendix A to enable near-infinite scalability while miti- gating risks of intermediate node default.

> 当前的交易状态下，这些交易可以被立即广播，或等待失效，通过为这个特定状态创建时间快照，就能利用比特币的交易脚本构建复杂的智能合约。此前，中心辐射型的微支付通道[7][8][9](以及可信支付通道[10][11])已经考虑了如何在今天构建一个中心辐射性微支付通道网络。但是，闪电网络的双向微支付通道需要比特币系统采取软分叉先解决附录中所描述的交易延展性问题，才能实现近乎无限的可扩展性，同时也能控制中间节点的出错风险。

By chaining together multiple micropayment channels, it is possible to create a network of transaction paths. Paths can be routed using a BGP- like system, and the sender may designate a particular path to the recipient. The output scripts are encumbered by a hash, which is generated by the recipient. By disclosing the input to that hash, the recipient’s counterparty will be able to pull funds along the route.

> 通过将多个微支付通道链接在一起，就有可能创建一个交易路径网络。路径可以使用类似BGP的协议进行路由选择，发送方可以指定特定的路径发送交易给接收方。输出脚本由接收方生成的散列来验证。通过提供散列的原像，接收方的交易对手就能够沿着这条路径传递资金。这种机制使得资金的转移可以在网络中安全、高效地进行，同时确保了接收方对交易的最终控制权。

### 3.1 The Problem of Blame in Channel Creation
### 3.1 通道创建中的责任问题

In order to participate in this payment network, one must create a micro- payment channel with another participant on this network.

> 为了参与到这个支付网络中来，参与者需要与网络中的另一方建立一个微支付通道。这意味着参与者之间需要建立一种特定的连接，通过它们可以进行加密货币的交换和交易。

#### 3.1.1 Creating an Unsigned Funding Transaction
#### 3.1.1 创建一个未签署的保证金交易

An initial channel Funding Transaction is created whereby one or both chan- nel counterparties fund the inputs of this transaction. Both parties create the inputs and outputs for this transaction but do not sign the transaction.

> 在建立微支付通道的初步阶段，通道的两个对手方需要创建一个称为通道资金交易的初始交易。在这个过程中，一个或双方都需要为这笔交易提供资金输入。虽然双方共同决定这笔交易的输入和输出内容，但在这个阶段，他们并不对交易进行签名。这样做的目的是为了在通道正式激活前，为双方提供一种调整或撤销交易的灵活性。

The output for this Funding Transaction is a single 2-of-2 multisigna-
ture script with both participants in this channel, henceforth named Alice and Bob. Both participants do not exchange signatures for the Funding Transaction until they have created spends from this 2-of-2 output refund- ing the original amount back to its respective funders. The purpose of not signing the transaction allows for one to spend from a transaction which does not yet exist. If Alice and Bob exchange the signatures from the Fund- ing Transaction without being able to broadcast spends from the Funding Transaction, the funds may be locked up forever if Alice and Bob do not cooperate (or other coin loss may occur through hostage scenarios whereby one pays for the cooperation from the counterparty).

> 这笔交易的输出是一个2/2多重签名地址，需要这个通道的双方参与者都同意才能花费这笔输出。我们按照惯例将通道两端的参与者命名为Alice和Bob。此时双方还不会为保证金交易交换签名，他们要先创建两笔花费，能够从保证金交易中将原始金额返还双方。不签署交易的目的是允许人们消费一个还不存在的交易。如果Alice和Bob在交换其签名之前广播保证金交易，此时一方不合作的话，这笔钱就可能被永久锁定(或者由一方承担了合作失败的损失)。

Alice and Bob both exchange inputs to fund the Funding Transaction(to know which inputs are used to determine the total value of the channel), and exchange one key to use to sign with later. This key is used for the 2-of-2 output for the Funding Transaction; both signatures are needed to spend from the Funding Transaction, in other words, both Alice and Bob need to agree to spend from the Funding Transaction.

> Alice和Bob互相交换保证金交易的输入(为了确定哪些输入用于确定通道的总容量)，然后交换一个密钥以供以后签名使用。这个密钥用于消费2/2保证金交易的输出，换句话说，如果要花费这笔保证金，需要Alice和Bob双方都同意。

#### 3.1.2 Spending from an Unsigned Transaction
#### 3.1.2 消费一笔未签名的交易

The Lightning Network uses a SIGHASH NOINPUT  transaction  to  spend from this 2-of-2 Funding Transaction output, as it is necessary to spend from a transaction for which the signatures are not yet exchanged. SIGHASH NOINPUT, implemented using a soft-fork, ensures transactions can be spent from before it is signed by all parties, as transactions would need to be signed to get a transaction ID without new sighash flags. Without SIGHASH NOINPUT, Bitcoin transactions cannot be spent from before they may be broadcast —it’s as if one could not draft a contract without paying the other party first. SIGHASH NOINPUT resolves this problem. See Appendix A for more information and implementation.

> 闪电网络使用 SIGHASH NOINPUT类型的交易来花费2/2保证金交易的输出，因为必须要构建一笔交易用于花费尚未交换签名的交易输出。SIGHASH NOINPUT将使用软分叉实现，它确保了交易可以在双方签署之前就能构造花费的交易，如果没有这个操作符的话，那交易就必须通过签署才能构造交易ID，那样就不能在广播这笔交易之前先来构造消费它的交易--这就好像一个人不先付款给另一方就不能起草合同一样。SIGHASH NOINPUT解决了这个问题，有关这方面更多信息和实现，亲参考附录A。

Without SIGHASH NOINPUT, it is not possible to generate a spend from a transaction without exchanging signatures, since spending the Fund- ing Transaction requires a transaction ID as part of the signature in the child’s input. A component of the Transaction ID is the parent’s (Funding Transaction’s) signature, so both parties need to exchange their signatures of the parent transaction before the child can be spent. Since one or both par- ties must know the parent’s signatures to spend from it, that means one or both parties are able to broadcast the parent (Funding Transaction) before the child even exists. SIGHASH NOINPUT gets around this by permitting the child to spend without signing the input. With SIGHASH NOINPUT, the order of operations are to:

> 如果没有SIGHASH NOINPUT，就无法在不交换签名的情况下生成花费它的交易，因为要花费保证金交易的输出，就需要交易ID作为花费交易输入的一部分。交易ID的一个组成部分是它的父交易方(即保证金交易)的签名，因此双方需要在创建子交易之前交换父交易的签名。由于一方或双方都需要夫交易的签名才能花费它，这就意味着一方或双方都能在子交易存在之前就能广播父交易(保证金交易)。SIGHASH NOINPUT允许子交易在不签署交易输入的情况下花费它，从而解决了这个问题。使用SIGHASH NOINPUT，操作顺序为：

1.Create the parent (Funding Transaction)

2.Create the children (Commitment Transactions and all spends from the commitment transactions)

3.Sign the children

4.Exchange the signatures for the children

5.Sign the parent

6.Exchange the signatures for the parent

7.Broadcast the parent on the blockchain

> 1.创建父交易(保证金交易)

> 2.创建子交易(承诺交易以及所有相关的承诺交易的花费)

> 3.为子交易签名

> 4.双方交换子交易的签名

> 5.为父交易签名

> 6.双方交换父交易的签名

> 7.在区块链上广播父交易

One is not able to broadcast the parent (Step 7) until Step 6 is com- plete. Both parties have not given their signature to spend from the Funding Transaction until step 6. Further, if one party fails during Step 6, the parent can either be spent to become the parent transaction or the inputs to the parent transaction can be double-spent (so that this entire transaction path is invalidated).

> 在第6步完成之前，不能广播父交易(步骤7)。在第6步之前，双方都没有签名同意花费保证金交易。此外，如果在第6步中，有一方作弊，即父交易被花费了，或者父交易的输入被双重支付，整个交易路径就都被认为是无效的。

#### 3.1.3 Commitment  Transactions:  Unenforcible Construction
#### 3.1.3 承诺交易: 不能强制履行

After the unsigned (and unbroadcasted) Funding Transaction has been cre- ated, both parties sign and exchange an initial Commitment Transaction. These Commitment Transactions spends from the 2-of-2 output of the Fund- ing Transaction (parent). However, only the Funding Transaction is broad- cast on the blockchain.

> 当还没有签名(且没有广播)的保证金交易创建完成之后，双方将签署并交换初始承诺交易。这些承诺交易花费的是2/2保证金交易的输出。值得注意的是，只有保证金交易才会广播上链。

Since the Funding Transaction has already entered into the blockchain, and the output is a 2-of-2 multisignature transaction which requires the agreement of both parties to spend from, Commitment Trans- actions are used to express the present balance. If only one 2-of-2 signed Commitment Transaction is exchanged between both parties, then both parties will be sure that they are able to get their money back after the Funding Transaction enters the blockchain. Both parties do not broadcast the Commitment Transactions onto the blockchain until they want to close out the current balance in the channel. They do so by broadcasting the present Commitment Transaction.

> 由于保证金交易已经广播入链，并且输出是一个2/2多重签名交易，这需要双方均同意才能花费，因此可以采用承诺交易来确认当前状态下双方的余额。如果双方之间只交换一笔2/2签名的承诺交易，而通过这笔交易，双方能确保在保证金交易广播入链后仍然能够取回资金。那么双方就不需要将承诺交易广播入链，除非他们希望关闭通道并结算余额。也只有这时候才需要广播承诺交易。

Commitment Transactions pay out the respective current balances to each party. A naive (broken) implementation would construct an unbroad- casted transaction whereby there is a 2-of-2 spend from a single transaction which have two outputs that return all current balances to both channel counterparties. This will return all funds to the original party when creat- ing an initial Commitment Transaction.

> 承诺交易会向每一方支付各自的流动余额。一个简单(不完整)的方法就是构建一笔交易，该交易花费2/2多重签名保证金交易的输入，有两个输出，就是将当前通道的余额返回给通道双方。通过创建这笔初始承诺交易，将会把通道资金的原始余额返回给双方。

![Figure1](figures/figure1.png?raw=true "Figure1")

Figure 1: A naive broken funding transaction is described in this diagram. The Funding Transaction (F), designated in green, is broadcast on the blockchain after all other trans- actions are signed. All other transactions spending from the funding transactions are not yet broadcast, in case the counterparties wish to update their balance. Only the Funding Transaction is broadcast on the blockchain at this time.

> 图1：图1描述了一个简单的分配保证金交易的方法。绿色的部分代表保证金交易(F)，当其他交易都签署之后才在区块链上广播，以防交易对手更新他们的通道余额。此场景中只有保证金交易才会被广播。

For instance, if Alice and Bob agree to create a Funding Transac- tion with a single 2-of-2 output worth 1.0 BTC (with 0.5 BTC contribution from each), they create a Commitment Transaction where there are two 0.5 BTC outputs for Alice and Bob. The Commitment Transactions are signed first and keys are exchanged so either is able to broadcast the Commitment Transaction at any time contingent upon the Funding Transaction enter- ing into the blockchain. At this point, the Funding Transaction signatures can safely be exchanged, as either party is able to redeem their funds by broadcasting the Commitment Transaction.

> 例如，如果Alice和Bob同意创建一笔包含1.0BTC(每一方存入0.5BTC)的2/2多重签名保证金交易，他们就需要创建一笔承诺交易，保证返还给Alice和Bob各自0.5BTC。双方首先对这笔承诺交易交换签名，这样在保证金交易广播入链后，任何一方都可以在任何时候广播这笔承诺交易。此时，可以放心的签署保证金交易，因为任何一方都可以通过广播承诺交易来赎回资金。

This construction breaks, however, when one wishes to update the present balance. In order to update the balance, they must update their Commitment Transaction output values (the Funding Transaction has al- ready entered into the blockchain and cannot be changed).

> 然而，当一方想要改变其当前通道内的余额时，这种结构就被打破了。为了更新余额，他们就必须更新他们的承诺交易的输出值(而保证金交易已经广播入链，不能更改了)。

When both parties agree to a new Commitment Transaction and exchange signatures for the new Commitment Transaction, either Commitment Transactions can be broadcast. As the output from the Funding Transaction can only be redeemed once, only one of those transactions will be valid. For instance, if Alice and Bob agree that the balance of the channel
is now 0.4 to Alice and 0.6 to Bob, and a new Commitment Transaction is created to reflect that, either Commitment Transaction can be broadcast. In effect, one would be unable to restrict which Commitment Transaction is broadcast, since both parties have signed and exchanged the signatures for either balance to be broadcast.

> 当双方都同意新的承诺交易并为其交换签名的时候，任何承诺交易都可以广播。由于保证金交易的输出只能花费一次，因此这些交易中只有一个是有效的。例如，如果Alice和Bob同意当前支付通道的余额分配是Alice拥有0.4BTC，Bob拥有0.6BTC，就需要创建一笔新的承诺交易来反映当前情况。此时之前的承诺交易也有可能被广播。实际上，当前无法限制广播哪个承诺交易，因为双方都已经交换的签名，任何一种余额分配的承诺交易都是可以广播的。


![Figure2](figures/figure2.png?raw=true "Figure2")

Figure 2: Either of the Commitment Transactions can be broadcast any any time by either party, only one will successfully spend from the single Funding Transaction. This cannot work because one party will not want to broadcast the most recent transaction.

> 图2：任何一方都可以在任何时间广播任何一笔承诺交易，当然，只有一笔是最终有效的。因为可能有一方并不希望广播最近的交易，却又无法限制这种情况，所以此方案存在缺陷。

Since either party may broadcast the Commitment Transaction at any time, the result would be after the new Commitment Transaction is gener- ated, the one who receives less funds has significant incentive to broadcast the transaction which has greater values for themselves in the Commitment Transaction outputs. As a result, the channel would be immediately closed and funds stolen. Therefore, one cannot create payment channels under this model.

> 由于任何一方都可以再任何时间广播承诺交易，那么在生成新的承诺交易后，持有较少资金的一方有显著的动机广播对自身输出金额更大的承诺交易。结果，该通道将立即关闭，资金将被窃取，因此，这种模式是无法安全的建立支付通道的。


#### 3.1.4 Commitment Transactions: Ascribing Blame
#### 3.1.4 承诺交易：归咎责任

Since any signed Commitment Transaction may be broadcast on the blockchain,  and only one can be successfully broadcast,  it is necessary   to prevent old Commitment Transactions from being broadcast.   It is   not possible to revoke tens of thousands of transactions in Bitcoin, so an alternate method is necessary. Instead of active revocation enforced by the blockchain, it’s necessary to construct the channel itself in similar manner to a Fidelity Bond, whereby both parties make commitments, and violations of these commitments are enforced by penalties. If one party violates their agreement, then they will lose all the money in the channel.

> 由于任何已签署的承诺交易都可以在区块链上广播，并且只能成功广播其中一笔交易，因此有必要防止旧的承诺交易被广播。但同时撤销数万笔比特币交易是不可能的，因此有必要采用另一种方法。与区块链强制执行的主动撤销不同，应该以类似于忠诚契约的方式来构造通道本身，双方据此作出承诺，当违反这些承诺时将会受到惩罚。如果一方违反了协议，他将失去通道中所有的资金。

For this payment channel, the contract terms are that both parties commit to broadcasting only the most recent transaction. Any broadcast of older transactions will cause a violation of the contract, and all funds are given to the other party as a penalty.

> 这种支付通道遵循这样的合同条款：双方承诺只广播最近的交易。任何旧交易的广播都将违反合同，所有的资金都将作为罚款给予另一方。

This can only be enforced if one is able to ascribe blame for broad- casting an old transaction. In order to do so, one must be able to uniquely identify who broadcast an older transaction. This can be done if each coun- terparty has a uniquely identifiable Commitment Transaction. Both parties must sign the inputs to the Commitment Transaction which the other party is responsible for broadcasting. Since one has a version of the Commitment Transaction that is signed by the other party, one can only broadcast one’s own version of the Commitment Transaction.

> 只有当一方可以对广播旧交易的另一方施以惩罚时，这一机制才能生效。为了做到这一点，必须能唯一的标识谁广播了较早的承诺交易。这需要每一方都有一笔唯一并可标识的承诺交易。双方必须签署对方负责广播的承诺交易的输入部分。由于每个参与者都持有对方签名的承诺交易的副本，因此他们只能广播自己版本的承诺交易。这样的安排确保了在违约情况下可以准确地识别并归责于违约方，从而维护交易的公正性和安全性。

For the Lightning Network, all spends from the Funding Transaction output, Commitment Transactions, have two half-signed transactions. One Commitment Transaction in which Alice signs and gives to Bob (C1b), and another which Bob signs and gives to Alice (C1a). These two Commitment Transactions spend from the same output (Funding Transaction), and have different contents; only one can be broadcast on the blockchain, as both pairs of Commitment Transactions spend from the same Funding Transac- tion. Either party may broadcast their received Commitment Transaction by signing their version and including the counterparty’s signature. For ex- ample, Bob can broadcast Commitment C1b, since he has already received the signature for C1b from Alice —he includes Alice’s signature and signs C1b himself. The transaction will be a valid spend from the Funding Trans- action’s 2-of-2 output requiring both Alice and Bob’s signature.

> 对于闪电网络，所有的来自于保证金交易的输出的花费，即承诺交易们，都只有一半签名。其中 Alice对一笔承诺交易签名并发给Bob(C1b)，Bob对另一笔承诺交易并发给Alice(C1a)。这两笔承诺交易的输入来自于同一笔(保证金)交易，但是内容不同；这两笔交易只有一笔可以在区块链上广播。任何一方都可以收到包含对方签名的承诺交易，然后加上自己的签名进行广播。例如，Bob可以广播承诺交易C1b，因为他已经从Alice那里收到了C1b的签名--他只需要再对C1b自己签署一遍就可以了。这笔交易将是保证金交易2/2输出的有效花费，因为同时包含了Alice和Bob的签名。

![Figure3](figures/figure3.png?raw=true "Figure3")

Figure 3: Purple boxes are unbroadcasted transactions which only Alice can broadcast. Blue boxes are unbroadcasted transaction which only Bob can broadcast. Alice can only broadcast Commitment 1a, Bob can only broadcast Commitment 1b. Only one Commit- ment Transaction can be spent from the Funding Transaction output. Blame is ascribed, but either one can still be spent with no penalty.

> 图3：紫色方框是没有广播的交易，只有Alice可以广播。同理，蓝色方框也是没有广播的交易，只有Bob才能广播。Alice只能广播承诺交易1a，Bob只能广播承诺交易1b。消费保证金交易的输出中只有一笔承诺交易可以成功花费。在责任约束下，只有一方可以毫无代价的花费掉资金。

However, even with this construction, one has only merely allocated blame. It is not yet possible to enforce this contract on the Bitcoin blockchain. Bob still trusts Alice not to broadcast an old Commitment Transaction. At this time, he is only able to prove that Alice has done so via a half-signed transaction proof.

> 然而，即使有了这样的机制，也只是责任上的约束。目前尚不可能在比特币区块链上执行该合约。Bob仍需要信任Alice不会广播旧的承诺交易。在这个例子中，他只能通过一笔完成一半签名的交易来信任Alice。(译者注：这意味着，尽管责任已经明确分配，但在区块链技术层面上，还没有有效的机制来确保和强制执行这些责任分配。这种局限性暴露了当前构造中对信任的依赖，以及缺乏强制执行机制的问题。)

### 3.2 Creating a Channel with Contract Revocation

### 3.2 创建能够撤销合约的通道

To be able to actually enforce the terms of the contract, it’s necessary to construct a Commitment Transaction (along with its spends) where one is able to revoke a transaction. This revocation is achievable by using data about when a transaction enters into a blockchain and using the maturity of the transaction to determine validation paths.

> 为了能够确实的执行合约，有必要构建这样一笔承诺交易：交易本身以及这笔交易的输出花费，都是可撤销的。可以通过控制这笔交易何时广播入链，并使用交易的到期时间来确定验证路径，从而实现这种撤销。

### 3.3 Sequence Number Maturity

### 3.3 序列数到期时间

Mark Freidenbach has proposed that Sequence Numbers can be en- forcible via a relative block maturity of the parent transaction via a soft-fork[12].  This would allow some basic ability to ensure some form   of relative block confirmation time lock on the spending script. In addition, an additional opcode, OP CHECKSEQUENCEVERIFY[13] (a.k.a.  OP RELATIVECHECKLOCKTIMEVERIFY)[14], would permit further abilities, including allowing a stop-gap solution before a more permanent solution for resolving transaction malleability. A future version of this paper will include proposed solutions.

> Mark Freidenbach提出了一种方法，通过软分叉[12]，可以设置一个序列数字，只有父交易的区块确认数达到序列数的要求后，交易才能生效。这将允许支出脚本实现一些基本的功能，可以在区块达到一定确认数目之后才会执行。另外，还可以增加一个操作码，OP_CHECKSEQUENCEVERIFY[13] (或者命名为OP_RELATIVECHECKLOCKTIMEVERIFY)[14]，它将允许更多的功能，包括在完全解决交易延展性问题的方案实行之前先实行一个临时解决方案。本文将来会持续更新建议的解决方案。


To summarize, Bitcoin was released with a sequence number which was only enforced in the mempool of unconfirmed transactions. The origi- nal behavior permitted transaction replacement by replacing transactions in the mempool with newer transactions if they have a higher sequence num- ber. Due to transaction replacement rules, it is not enforced due to denial of service attack risks. It appears as though the intended purpose of the sequence number is to replace unbroadcasted transactions. However, this higher sequence number replacement behavior is unenforcible. One cannot be assured that old versions of transactions were replaced in the mempool and a block contains the most recent version of the transaction. A way to enforce transaction versions off-chain is via time commitments.

> 总而言之，比特币系统会将这些带有序列数的交易一直强制放在内存池中，暂时不打包进区块链。如果内存池中有另外一笔交易包含更高的序列数，就用这笔交易替换原先的交易。根据交易替换的规则，由于存在拒绝服务攻击的风险，这不是强制执行的。表面上看，引入序列号的目的是更新未成功广播的交易。但是，这种更高的序列号交易替换行为不是强制的。并不能绝对保证内存池中交易的旧版本一定会被替换，也不能保证区块中一定打包进最新版本的交易。这需要在链下通过时间承诺的方法强制确保最新的交易生效。

A Revocable Transaction spends from a unique output where the transaction has a unique type of output script. This parent’s output has two redemption paths where the first can be redeemed immediately, and the second can only be redeemed if the child has a minimum number of con- firmations between transactions. This is achieved by making the sequence number of the child transaction require a minimum number of confirmations from the parent. In essence, this new sequence number behavior will only permit a spend from this output to be valid if the number of blocks between the output and the redeeming transaction is above a specified block height.

> 一笔可撤销的交易的输入来自于特定唯一输出的一笔交易。这些父交易都有两个输出，其中第一个可以立即被赎回，第二个只能在当前交易得到足够确认数的情况下才能赎回。这种机制是通过设置子交易的序列号，要求从父交易开始至少有一定数量的区块确认。实际上，这种新的包含有序列数的交易，只允许输出和赎回交易之间的区块数目超过指定高度时，此输出的花费才有效。

A transaction can be revoked with this sequence number behavior by creating a restriction with some defined number of blocks defined in the sequence number, which will result in the spend being only valid after the parent has entered into the blockchain for some defined number of blocks. This creates a structure whereby the parent transaction with this output becomes a bonded deposit, attesting that there is no revocation. A time period exists which anyone on the blockchain can refute this attestation by broadcasting a spend immediately after the transaction is broadcast.

> 一笔交易可以通过设定一个序列数的方法撤销，创建一笔次包含序列数的交易，当其父交易广播入链后，再经过指定数目的区块确认之后此交易才能生效。这创建了一个结构，其中具有该输出的父交易成为一笔有担保的存款，以证明此交易还没有撤销。锁定时间内，如果有人广播这笔交易想要花费它，其他任何人都能立即检测到这笔支出来反驳这一证明。

If one wishes to permit revocable transactions with a 1000- confirmation delay, the output transaction construction would remain a 2-of-2 multisig:

> 如果一个人希望允许将可撤销的交易延迟确认时间设置为1000个确认，那么如果这是一笔2/2多重签交易的话，输出的构造是这样的：

```
2 <Alice1> <Bob1> 2 OP CHECKMULTISIG
```

However, the child spending transaction would contain a nSequence value of 1000. Since this transaction requires the signature of both coun- terparties to be valid, both parties include the nSequence number of 1000 as part of the signature. Both parties may, at their discretion, agree to create another transaction which supersedes that transaction without any nSequence number.

> 然后，消费它的子交易将包含一个序列数1000。由于此交易需要双方的签名才能生效，所以双方都将序列数1000作为签名的一部分。双方可以根据情况自行决定创建另一笔没有序列数的交易来废弃原先的交易。

This construction, a Revocable Sequence Maturity Contract (RSMC), creates two paths, with very specific contract terms.

> 这个结构，被称作序列到期可撤销合约(RSMC)，它通过非常具体的智能合约，创建了两个花费保证金交易的路径。

The contract terms are:

> 合约条款如下：

1. All parties pay into a contract with an output enforcing this contract

2. Both parties may agree to send funds to some contract, with some waiting period (1000 confirmations in our example script). This is the revocable output balance.

3. One or both parties may elect to not broadcast (enforce) the payouts until some future date; either party may redeem the funds after the waiting period at any time.

4. If neither party has broadcast this transaction (redeemed the funds), they may revoke the above payouts if and only if both parties agree to do so by placing in a new payout term in a superseding transaction pay- out. The new transaction payout can be immediately redeemed after the contract is disclosed to the world (broadcast on the blockchain).

5. In the event that the contract is disclosed and the new payout structure is not redeemed, the prior revoked payout terms may be redeemed by either party (so it is the responsibility of either party to enforce the new terms).

> 1. 双方签订一份合约，该合约有一个输出确保执行

> 2. 双方同意发送一部分资金给合约，这部分资金需要一段时间才能解锁使用(在我们的例子中需要1000个确认)。这部分输出金额是可以撤销的。

> 3. 一方或双方可以暂时不广播支付交易；直到等待期之后，任何一方都可以随时赎回资金。

> 4. 如果双方都没有广播这笔交易(赎回资金)，只有双方同意在替代交易的支出中加入新的合约时，他们才可以撤销上述支出。新的交易支出可以在合约披露(广播入链)后立即赎回。

> 5. 如果合约被披露，新的支付却没有立即被赎回，任何一方都可以赎回之前被撤销的支付条款（因此，任何一方都有责任执行新合约）。

The pre-signed child transaction can be redeemed after the parent transaction has entered into the blockchain with 1000 confirmations, due to the child’s nSequence number on the input spending the parent.

> 在父交易经过1000个确认之后，预签名的子交易输出可以赎回。这是因为子交易输入中的序列数受它所花费的父交易的限制。
In order to revoke this signed child transaction, both parties just agree to create another child transaction with the default field of the nSequence number of MAX INT, which has special behavior permitting spending at any time.

> 为了撤销这笔已经签名的子交易，双方需要协商使用MAX_INT类型的序列数默认字段创建另一笔子交易，该字段具有允许随时花费的特殊行为。

This new signed spend supersedes the revocable spend so long as the new signed spend enters into the blockchain within 1000 confirmations of the parent transaction entering into the blockchain. In effect, if Alice and Bob agree to monitor the blockchain for incorrect broadcast of Commitment Transactions, the moment the transaction gets broadcast, they are able to spend using the superseding transaction immediately. In order to broadcast the revocable spend (deprecated transaction), which spends from the same output as the superseding transaction, they must wait 1000 confirmations. So long as both parties watch the blockchain, the revocable spend will never enter into the transaction if either party prefers the superseding transaction.

> 只要新签名交易的花费在父交易1000个确认时间内广播入链，这笔交易就会取代之前可撤销的承诺交易。实际上，如果Alice和Bob一支在监视区块链，当有人作弊想要广播旧的承诺交易时，他们可以立即广播其替代交易。而作弊者广播的交易需要等待1000个确认，在这之前其资金已经被替代交易花费掉了。所以只要双方都关注区块链，同一时间总有一方更倾向于广播替代交易，那么实际上可撤销的承诺交易永远不会实际进入区块链上。

Using this construction, anyone could create a transaction, not broad-
cast the transaction, and then later create incentives to not ever broadcast that transaction in the future via penalties. This permits participants on the Bitcoin network to defer many transactions from ever hitting the blockchain.

> 通过这种结构，任何人都可以仅创建一笔交易而不去立即广播它，这以后通过惩罚来约束人们不去实际广播这笔交易。这使得比特币网络上的参与者可以把许多交易推迟广播入链。

#### 3.3.1 Timestop

#### 3.3.1 减时标识

To mitigate a flood of transactions by a malicious attacker requires a credible threat that the attack will fail.

> 为了减少恶意攻击者发起的大量灰尘交易，需要一个可靠的震慑方案来阻止攻击。

Greg Maxwell proposed using a timestop to mitigate a malicious flood on the blockchain:

There are many ways to address this [flood risk] which haven’t been adequately explored yet —for example, the clock can stop when blocks are full; turning the security risk into more hold-up delay in the event of a dos attack.[15]

> Greg Maxwell 提出了一种方法，即使用“时间停止”策略来减轻区块链上恶意交易泛滥的问题：

> 尽管目前还没有充分探索，但存在多种潜在的解决方案来应对这类洪水风险。--例如，可以在区块链写满的时候停止计时，这种做法能够将由于拒绝服务（DoS）攻击带来的安全风险转化为更长的交易确认延迟。

This can be mitigated by allowing the miner to specify whether the current (fee paid) mempool is presently being flooded with transactions. They can enter a “1” value into the last bit in the version number of the block header. If the last bit in the block header contains a “1”, then that block will not count towards the relative height maturity for the nSequence value and the block is designated as a congested block. There is an uncongested block height (which is always lower than the normal block height). This block height is used for the nSequence value, which only counts block maturity (confirmations).

> 这种情况可以通过一种方法来缓解：允许矿工判断当前（已支付费用的）内存池是否正遭受大量交易的泛滥。他们可以把区块头版本号的最后一位置为”1”。如果区块头最后一位包含”1”，那么该区块不计入nSequence值的相对高度成熟度，并且指定该区块为拥塞块。同时引入一个指标代表不拥挤的块的块高度(这个值总是低于正常块高度)。这个块高度用于与nSequence值比较，它只用于计算块的成熟度（确认数）。

A miner can elect to define the block as a congested block or not. The default code could automatically set the congested block flag as “1” if the mempool is above some size and the average fee for that set size is above some value. However, a miner has full discretion to change the rules on what automatically sets as a congested block, or can select to permanently set the congestion flag to be permanently on or off. It’s expected that most honest miners would use the default behavior defined in their miner and not organize a 51% attack.

> 矿工有权选择是否将某个区块定义为拥堵区块。如果内存池的大小超过特定阈值，且该内存池中的交易的平均手续费也超过某个值，那么默认的代码逻辑可以自动将该区块的拥堵标志设置为“1”。然而，矿工完全有权修改这种自动设置拥堵区块的规则，或者选择将拥堵标志永久地设置为开启或关闭状态。通常情况下，大多数诚实的矿工会采用他们矿机中定义的默认设置，并不会参与组织51%攻击。这种机制提供了灵活性，允许矿工根据网络的实际情况来调整区块的拥堵标志，从而在网络拥堵时采取相应的措施，以维护整个比特币网络的稳定和安全。

For example, if a parent transaction output is spent by a child with a nSequence value of 10, one must wait 10 confirmations before the transaction becomes valid. However, if the timestop flag has been set, the counting of confirmations stops, even with new blocks. If 6 confirmations have elapsed (4 more are necessary for the transaction to be valid), and the timestop block has been set on the 7th block, that block does not count towards the nSequence requirement of 10 confirmations; the child is still at 6 blocks for the relative confirmation value. Functionally, this will be stored as some kind of auxiliary timestop block height which is used only for tracking the timestop value. When the timestop bit is set, all transactions using an nSe- quence value will stop counting until the timestop bit has been unset. This gives sufficient time and block-space for transactions at the current auxil- iary timestop block height to enter into the blockchain, which can prevent systemic attackers from successfully attacking the system.

> 举例来说，如果一个nSequence值为10的子交易消费了其父交易的输出，就必须等待父交易10个确认后才能生效。但是，如果设置了timestop标识，即使产生新的区块，确认数也可能停止计数。比如经过了6个确认之后(还需要另外4个确认才能让交易有效)，第7个区块设定了timestop标识，那么该区块就不会计入nSequence的计数器。对于子交易来说，相对确认数仍然是6。要实现这些，就需要一个跟踪timestop 标识的区块高度值。当设置了timestop标识时，所有使用nSequence的交易将停止确认数计数，直到下一个没有设置timestop标识的区块入链。这为当前受timestop标识的块影响的交易进入区块链提供了足够的时间和块空间，这可以成功防止攻击者。

However, this requires some kind of flag in the block to designate whether it is a timestop block. For full SPV compatibility (Simple Payment Verification; lightweight clients), it is desirable for this to be within the 80- byte block header instead of in the coinbase. There are two places which may be a good place to put in this flag in the block header: in the block time and in the block version. The block time may not be safe due to the last bits being used as an entropy source for some ASIC miners, therefore a bit may need to be consumed for timestop flags. Another option would be to hardcode timestop activation as a hard consensus rule (e.g. via block size), however this may make things less flexible. By setting sane defaults for timestop rules, these rules can be changed without consensus soft-forks.

> 但是，这需要在块中使用某种标记来指定它是否是timestop区块，还要完全兼容SPV(简单支付验证，轻客户端)，最好设定在区块头的80字节中，而不是coinbase信息里。区块头有两个地方可以很好的放入这个标记：块时间戳或者块版本号。块时间戳可能是不安全的，因为最后一个位空间被一些ASIC矿工用作随机熵源。另一种选择是将timestop激活硬编码为一个严格的一致规则（例如，通过区块大小来区分），但这可能会降低灵活性。要想为timestop设定一个健全的机制，最好可以不需要软分叉就能调整这些规则。

If the block version is used as a flag, the contextual information must match the Chain ID used in some merge-mined coins.

> 如果使用块版本号作为标识，那么在合并挖矿中，上下文信息必须保持一致的Chain ID。


#### 3.3.2 Revocable Commitment Transactions

#### 3.3.2 可撤销的承诺交易

By combining the ascribing of blame as well as the revocable transaction, one is able to determine when a party is not abiding by the terms of the contract, and enforce penalties without trusting the counterparty.

> 把责任归咎和可撤销交易结合起来，就可以确定对方何时不遵守合约，无需互相授信就可以处罚对方。

![Figure4](figures/figure4.png?raw=true "Figure4")

Figure 4: The Funding Transaction F, designated in green, is broadcast on the blockchain after all other transactions are signed. All transactions which only Alice can broadcast are in purple. All transactions which only Bob can broadcast is are blue. Only the Funding Transaction is broadcast on the blockchain at this time.

> 图4:当所有其它交易签署之后，在区块链上广播绿色方框的保证金交易F。所有只有Alice可以广播的交易用紫色方框标识。所有只有Bob可以广播的交易用蓝色方框标识。只有保证金交易才会广播入链。

The intent of creating a new Commitment Transaction is to invalidate all old Commitment Transactions when updating the new balance with a new Commitment Transaction. Invalidation of old transactions can happen by making an output be a Revocable Sequence Maturity Contract (RSMC). To invalidate a transaction, a superseding transaction will be signed and exchanged by both parties that gives all funds to the counterparty in the event an older transaction is incorrectly broadcast. The incorrect broadcast is identified by creating two different Commitment Transactions with the same final balance outputs, however the payment to oneself is encumbered by an RSMC.

> 创建新承诺交易的目的是：当更新交易通道双方余额时，通过使用序列到期可撤销合约(RSMC)，作废旧的承诺交易。为了做到这些，交易双方将签署和交换一笔替代交易，如果旧的承诺交易被错误广播，广播方就会失去所有的资金。这里的两笔承诺交易的输出金额相同，但是返还给自己的输出受RSMC的制约。

In effect, there are two Commitment Transactions from a single Fund- ing Transaction 2-of-2 outputs. Of these two Commitment Transactions, only one can enter into the blockchain. Each party within a channel has one version of this contract. So if this is the first Commitment Transaction pair, Alice’s Commitment Transaction is defined as C1a, and Bob’s Commitment Transaction is defined as C1b. By broadcasting a Commitment Transac- tion, one is requesting for the channel to close out and end. The first two outputs for the Commitment Transaction include a Delivery Transaction (payout) of the present unallocated balance to the channel counterparties. If Alice broadcasts C1a, one of the output is spendable by D1a, which sends funds to Bob. For Bob, C1b is spendable by D1b, which sends funds to Alice. The Delivery Transaction (D1a/D1b) is immediately redeemable and is not encumbered in any way in the event the Commitment Transaction is broadcast.

> 实际上，两笔承诺交易来自于同一笔2/2多重签名保证金交易的输出。这两笔承诺交易，最终只有一笔能广播入链。交易通道双方各持有这笔合约交易的一个版本，比如第一对承诺交易，Alice持有的承诺交易定义为C1a，Bob持有的承诺交易定义为C1b。直到有一方请求关闭支付通道时，才会广播C1a或C1b。承诺交易有两个输出，其中一个输出将当前未分配余额支付给通道对手方。如果Alice广播C1a，其中一个输出可由D1a消费，D1a将向Bob发送资金。对于Bob来说，C1b可以被D1b消费，D1b会向Alice发送资金。当承诺交易广播后，支付交易(D1a/D1b)都可以立即赎回。

For each party’s Commitment Transaction, they are attesting that they are broadcasting the most recent Commitment Transaction which they own. Since they are attesting that this is the current balance, the balance paid to the counterparty is assumed to be true, since one has no direct benefit by paying some funds to the counterparty as a penalty.

> 对于当前持有承诺交易的双方，他们会倾向于只广播各自持有的承诺交易，此交易反映了双方的资金余额，这些支付给对手方的余额是正确的，因为广播另外的承诺交易会损失资金，并不会为自己带来好处。

The balance paid to the person who broadcast the Commitment Transaction, however, is unverified. The participants on the blockchain have no idea if the Commitment Transaction is the most recent or not. If they do not broadcast their most recent version, they will be penalized by taking all the funds in the channel and giving it to the counterparty. Since their own funds are encumbered in their own RSMC, they will only be able to claim their funds after some set number of confirmations after the Commitment Transaction has been included in a block (in our example, 1000 confirmations). If they do broadcast their most recent Commitment Transaction, there should be no revocation transaction superseding the revocable transaction, so they will be able to receive their funds after some set amount of time (1000 confirmations).

> 然而，广播承诺交易的一方收到的资金是未经核实的。参与者并不能通过区块链分辨这是否是最近的承诺交易。由于他们自己的资金锁定在RSMC中，他们只能在承诺交易进入区块链经过指定数目的确认(在我们的示例中，是1000个确认)之后，才能提取资金， 如果广播的承诺交易不是最新版本，他们将会受到惩罚，会失去通道内的资金。如果他们确实广播了最近的承诺交易，那么就不会有人广播撤销交易，他们将能够在一定时间后收到他们的资金（1000个确认）。

By knowing who broadcast the Commitment Transaction and encum- bering one’s own payouts to be locked up for a predefined period of time, both parties will be able to revoke the Commitment Transaction in the fu- ture.

> 通过监视谁广播了承诺交易，并将自己的支付所锁定一段预定的时间，将来双方都可以撤销承诺交易。

#### 3.3.3 Redeeming Funds from the Channel: Cooperative Counterparties 

#### 3.3.3 从支付通道中赎回资金：双方合作

Either party may redeem the funds from the channel. However, the party that broadcasts the Commitment Transaction must wait for the predefined number of confirmations described in the RSMC. The counterparty which did not broadcast the Commitment Transaction may redeem the funds im- mediately.

> 虽然任何一方都可以从该通道赎回资金。然而，广播承诺交易的一方必须等待区块确认数到达RSMC中描述的预定义确认数才能赎回。没有广播承诺交易的对手方可以即时赎回承诺资金。

For example, if the Funding Transaction is committed with 1 BTC (half to each counterparty) and Bob broadcasts the most recent Commit- ment Transaction, C1b, he must wait 1000 confirmations to receive his 0.5 BTC, while Alice can spend 0.5 BTC. For Alice, this transaction is fully closed if Alice agrees that Bob broadcast the correct Commitment Transac- tion (C1b).

> 例如，如果一笔保证金交易锁定了1BTC(每一方有0.5BTC)，Bob广播了最近的承诺交易C1b，他必须等待1000个确认之后才能赎回属于他的0.5BTC，同时Alice可以立即收到她的0.5BTC。对于Alice来说，如果Alice同意Bob广播的承诺交易C1b是正确的，那支付通道就可以关闭。

![Figure5](figures/figure5.png?raw=true "Figure5")

Figure 5: When Bob broadcasts C1b, Alice can immediately redeem her portion. Bob must wait 1000 confirmations. When the block is immediately broadcast, it is in this  state. Transactions in green are transactions which are committed into the blockchain.

> 图5: 当Bob广播C1b时，Alice可以立即赎回她的的部分，而Bob必须等待1000个确认。当交易广播时，就处于图上这种状况。绿框中代表打包到区块链后立即生效的交易。

After the Commitment Transaction has been in the blockchain for 1000 blocks, Bob can then broadcast the Revocable Delivery transaction. He must wait 1000 blocks to prove he has not revoked this Commitment Transaction (C1b). After 1000 blocks, the Revocable Delivery transaction will be able to be included in a block. If a party attempt to include the Revocable Delivery transaction in a block before 1000 confirmations, the transaction will be invalid up until after 1000 confirmations have passed (at which point it will become valid if the output has not yet been redeemed).

> 承诺交易打包进区块链中经过1000个确认之后，Bob才可以广播赎回交易来收回资金。他必须等待1000个确认来证明自己没有撤销这笔承诺交易(C1b)。在1000个确认之后，承诺交易的赎回部分才能打包进块。如果一方试图在1000个确认之前将可撤销的赎回交易打包入块，那么这笔交易将会失效，一定需要等1000个确认之后，如果此时输出尚未赎回，那么该交易才是有效的。

![Figure6](figures/figure6.png?raw=true "Figure6")

Figure 6:  Alice agrees that Bob broadcast the correct Commitment Transaction and  1000 confirmations have passed. Bob then is able to broadcast the Revocable Delivery (RD1b) transaction on the blockchain.

> 图6： Alice同意Bob广播的承诺交易是正确的。这笔交易也经过了1000个确认，此时Bob可以在区块链上广播可撤销赎回交易(RD1b)


After Bob broadcasts the Revocable Delivery transaction, the channel is fully closed for both Alice and Bob, everyone has received the funds which they both agree are the current balance they each own in the channel.

> 当Bob广播可撤销赎回交易时，他与Alice之间的支付通道完全关闭，每个人都收回了他们协商一致的资金，这些资金是他们各自在支付通道中拥有的当前余额。

If it was instead Alice who broadcast the Commitment Transaction (C1a), she is the one who must wait 1000 confirmations instead of Bob.

> 如果广播承诺交易(C1a)的是Alice，那么她必须等待1000个确认，而不是Bob。

#### 3.3.4 Creating a new Commitment Transaction and Revoking Prior Commitments 

#### 3.3.4 创建新的承诺交易并撤销之前的承诺交易

While each party may close out the most recent Commitment Transaction at any time, they may also elect to create a new Commitment Transaction and invalidate the old one.
Suppose Alice and Bob now want to update their current balances from 0.5 BTC each refunded to 0.6 BTC for Bob and 0.4 BTC for Alice.

When they both agree to do so, they generate a new pair of Commitment Transactions.

![Figure7](figures/figure7.png?raw=true "Figure7")

Figure 7: Four possible transactions can exist, a pair with the old commitments, and another pair with the new commitments. Each party inside the channel can only broadcast half of the total commitments (two each). There is no explicit enforcement preventing any particular Commitment being broadcast other than penalty spends, as they are all valid unbroadcasted spends.  The Revocable Commitment  still exists with the C1a/C1b pair,  but are not displayed for brevity.

> 图7: 同时存在四笔可能的交易，包括一对旧的承诺交易，以及另外一对新承诺交易。支付通道中的每一方只能广播其中其中两笔承诺交易。除了罚款外，没有明确的强制措施阻止任何特定的承诺交易被广播，因为他们都具有合法的未花费的输入。可撤销的承诺仍然存在于C1a/C1b交易对中仍然存在，但是为了表示简单，没有画上去。

When a new pair of Commitment Transactions (C2a/C2b) is agreed upon, both parties will sign and exchange signatures for the new Commit- ment Transaction, then invalidate the old Commitment Transaction. This invalidation occurs by having both parties sign a Breach Remedy Trans- action (BR1), which supersedes the Revocable Delivery Transaction (RD1). Each party hands to the other a half-signed revocation (BR1) from their own Revocable Delivery (RD1), which is a spend from the Commitment Transac- tion. The Breach Remedy Transaction will send all coins to the counterparty within the current balance of the channel. For example, if Alice and Bob both generate a new pair of Commitment Transactions (C2a/C2b) and inval- idate prior commitments (C1a/C1b), and later Bob incorrectly broadcasts C1b on the blockchain, Alice can take all of Bob’s money from the channel. Alice can do this because Bob has proved to Alice via penalty that he will never broadcast C1b, since the moment he broadcasts C1b, Alice is able to take all of Bob’s money in the channel. In effect, by constructing a Breach Remedy transaction for the counterparty, one has attested that one will not be broadcasting any prior commitments. The counterparty can accept this, because they will get all the money in the channel when this agreement is violated.

> 当新的承诺交易对(C2a/C2b)达成一致时，双方将各自签署新的承诺交易并交换签名，然后作废旧的承诺交易。作废交易是通过双方签署违约补偿交易(BR1)实现的，BR1取代了可撤销传送交易(RD1)。每一方从其自身的可撤销传送交易(RD1)中向另一方提交一份已经签署了一半的撤销部分(BR1)，这是承诺转让的费用。违约补偿交易将把通道内所有剩余的资金发送给对方。例如，如果Alice和Bob都生成了一对新的承诺交易(C2a/C2b)，并废弃了之前的承诺交易(C1a/C1b)，然后Bob在区块链上错误的广播了C1b，那么Alice可以从Bob的通道中拿走所有的钱。因为Bob已经通过补偿合约向Alice证明了他永远不会广播C1b，所以自从他广播C1b的那一刻起，Alice就可以拿走Bob在通道内所有的资金。实际上，通过构建一个违约补偿协议，你就声明了你将不会广播任何之前的承诺交易。你的交易对手也会乐意接收这个协议，因为当你违反它时，他就会得到通道内所有的资金。

![Figure8](figures/figure8.png?raw=true "Figure8")

Figure 8: When C2a and C2b exist, both parties exchange Breach Remedy transactions. Both parties now have explicit economic incentive to avoid broadcasting old Commitment Transactions (C1a/C1b). If either party wishes to close out the channel, they will only use C2a (Alice) or C2b (Bob). If Alice broadcasts C1a, all her money will go to Bob. If Bob broadcasts C1b, all his money will go to Alice. See previous figure for C2a/C2b outputs.

> 图8:当C2a和C2b都构建之后，双方交换违约补偿交易。那么双方现在都有明确的经济动机来避免广播旧的承诺交易(C1a/C1b)。如果任何一方希望关闭通道，他们将只会广播C1a(Alice广播)或C2b(Bob广播)。如果Alice广播了C1a，她所有的资金都会给Bob。如果Bob广播了C1b，他所有的资金都会给Alice。C2a/C2b的输出见上图。

Due to this fact, one will likely delete all prior Commitment Transac- tions when a Breach Remedy Transaction has been passed to the counter- party. If one broadcasts an incorrect (deprecated and invalidated Commit- ment Transaction), all the money will go to one’s counterparty. For example, if Bob broadcasts C1b, so long as Alice watches the blockchain within the predefined number of blocks (in this case, 1000 blocks), Alice will be able to take all the money in this channel by broadcasting RD1b.  Even if the present balance of the Commitment state (C2a/C2b) is 0.4 BTC to Alice and 0.6 BTC to Bob, because Bob violated the terms of the contract, all the money goes to Alice as a penalty. Functionally, the Revocable Transaction acts as a proof to the blockchain that Bob has violated the terms in the channel and this is programatically adjudicated by the blockchain.

> 由于这一事实，当违约补偿交易已经发送给对手方时，可能会删除所有先前的承诺交易。如果广播了一笔错误的交易(对方不赞同或者无效)，通道内所有的钱将会给另一方。例如，如果Bob广播C1b，只要Alice在预定的新区块数内(在本例中为1000个新区快)一直监控区块链，Alice就能够通过广播RD1b接收该通道内的所有资金。即使当前承诺交易锁定(C1a/C2b)的余额分配为Alice 0.4BTC，Bob 0.6BTC也是这样。因为Bob违反了合约，作为惩罚，所有的钱都会给Alice。从功能上来看，可撤销的交易充当向区块链证明Bob违反了支付通道合约的证据，这是由区块链通过智能合约来裁定的。

![Figure9](figures/figure9.png?raw=true "Figure9")

Figure 9: Transactions in green are committed to the blockchain. Bob incorrectly broad- casts C1b (only Bob is able to broadcast C1b/C2b). Because both agreed that the current state is the C2a/C2b Commitment pair, and have attested to each party that old commit- ments are invalidated via Breach Remedy Transactions, Alice is able to broadcast BR1b and take all the money in the channel, provided  she does it within 1000 blocks after C1b  is broadcast.

> 图9: 绿框内的交易被广播到区块链。此时Bob不应该广播C1b(只有Bob可以广播C1b/C2b)。因为双方现在就C2a/C2b承诺交易对达成了一致，并承认各自持有的之前的包含违约补偿的承诺交易已经无效了，如果违反协议，Alice将能立即广播BR1b，不需要等待1000个确认。

However, if Alice does not broadcast BR1b within 1000 blocks, Bob may be able to steal some money, since his Revocable Delivery Transac- tion (RD1b) becomes valid after 1000 blocks. When an incorrect Commit- ment Transaction is broadcast, only the Breach Remedy Transaction can be broadcast for 1000 blocks (or whatever number of confirmations both parties agree to). After 1000 block confirmations, both the Breach Remedy (BR1b) and Revocable Delivery Transactions (RD1b) are able to be broad- cast at any time. Breach Remedy transactions only have exclusivity within this predefined time period, and any time after of that is functionally an expiration of the statute of limitations —according to Bitcoin blockchain consensus, the time for dispute has ended.

> 但是，如果Alice没有在1000个确认内广播BR1b，Bob可能会偷走一些资金，因为它可以在1000个确认之后广播RD1b。当一方广播了错误的交易时，只有违约补偿交易可以不用等1000个确认就可以广播(不管双方协商多少确认数)。在1000个确认之后，违约补偿交易(BR1b)和可撤销传送交易(RD1b)可以在任何时候广播。违约补偿交易只有在预定义的时间段内具有排他性，在次之后的任何时间都是可以正常执行的--因为根据比特币区块链共识，限制时间已经结束了。

For this reason, one should periodically monitor the blockchain to see if one’s counterparty has broadcast an invalidated Commitment Transaction, or delegate a third party to do so. A third party can be delegated by only giving the Breach Remedy transaction to this third party. They can be incentivized to watch the blockchain broadcast such a transaction in the event of counterparty maliciousness by giving these third parties some fee in the output. Since the third party is only able to take action when the counterparty is acting maliciously, this third party does not have any power to force close of the channel.

> 因此，应该时刻监控区块链，以查看对方是否自己广播了非法的承诺交易，或者委托了第三方来监控。只要将违约补偿交易发送给第三方，就能委托监控。如果交易对手存在广播恶意交易的风险，那么可以通过在交易输出中向第三方监控者支付一定费用来激励他们监视区块链是否广播了这样的交易。另外三方监控者只能在交易对手发生恶意行为的时候采取行动，他无权强制关闭该通道。

#### 3.3.5 Process for Creating Revocable Commitment Transactions

#### 3.3.5 创建可撤销承诺交易的过程

To create revocable Commitment Transactions, it requires proper construc- tion of the channel from the beginning, and only signing transactions which may be broadcast at any time in the future, while ensuring that one will not lose out due to uncooperative or malicious counterparties. This re- quires determining which public key to use for new commitments, as us- ing SIGHASH NOINPUT requires using unique keys for each Commitment Transaction RSMC (and HTLC) output. We use P to designate pubkeys and K to designate the corresponding private key used to sign.

> 要创建可撤销承诺交易，需要一开始创建合适的支付通道，并签署在未来任何时候都可以广播的交易，同时确保不会因不合作或恶意的对手方而遭受损失。这个问题决定了新的承诺交易最终使用哪个公钥，因为使用SIGHASH NOINPUT操作符要求每一笔RSMC交易(以及HTLC)的输出都要使用唯一的密钥对。我们使用P来代表公钥，使用K代表用于签名的对应私钥。

When generating the first Commitment Transaction, Alice and Bob agree to create a multisig output from a Funding Transaction with a single multisig(PAliceF , PBobF ) output, funded with 0.5 BTC from Alice and Bob  for a total of 1 BTC. This output is a Pay to Script Hash[16] transaction, which requires both Alice and Bob to both agree to spend from the Funding Transaction. They do not yet make the Funding Transaction (F) spendable. Additionally, PAliceF and PBobF are only used for the Funding Transaction, they are not used for anything else.

> 当生成第一笔承诺交易时，Alice和Bob协商使用(PAliceF , PBobF )多签名创建一笔保证金交易，交易输出由Alice和Bob各提供0.5BTC资金，总共提供1BTC，这个输出是一个Pay to Script Hash脚本，需要Alice和Bob一致同意才能消费这笔交易。如果有一个人不同意，就无法消费这笔交易。此外，PAliceF 和 PBobF  仅能用于这笔保证金交易，不能有其它用途。

Since the Delivery transaction is just a P2PKH output (bitcoin ad- dresses beginning with 1) or P2SH transaction (commonly recognized as ad- dresses beginning with the 3) which the counterparties designate beforehand, this can be generated as an output of PAliceD and PBobD. For  simplicity, these output addresses will remain the same throughout the channel, since its funds are fully controlled by its designated recipient after the Commit- ment Transaction enters the blockchain. If desired, but not necessary, both parties may update and change PAliceD and PBobD for future Commitment Transactions.

> 由于传送交易是交易对手事先指定的P2PKH交易(比特币地址由1开头)或P2SH交易(比特币地址由3开头)，它作为PAliceD 和 PBobD 址共同签名才能花费的输出来构造。简单起见，如果需要的话，这些输出地址在通道中保持不变，在广播承诺交易打包进区块链之后，其资金完全由指定的接收方控制。但这不是必须的，双方可以在未来的承诺交易中更新或更换PAliceD 和 PBobD 。

Both parties exchange pubkeys they intend to use for the RSMC (and HTLC described in future sections) for the Commitment Transaction. Each set of Commitment Transactions use their own public keys and are not ever reused.  Both parties may already know all future pubkeys by  using  a BIP 0032[17] HD Wallet construction by exchanging Master Public Keys during channel construction. If they wish to generate a new Commitment Transaction pair C2a/C2b, they use  multisig(PAliceRSMC2,  PBobRSMC2)  for the RSMC output.

> 双方交换他们打算用于承诺交易中RSMC(以后后面章节描述的HTLC)的公钥。每一对承诺交易都使用自己的公钥，并且永远不会被重用。双方可能就所有未来的公钥达成共识，遵循BIP 0032[17] HD钱包的实现，在通道创建时交换各自的主密钥(Master Public Keys)。如果双方需要生成新的承诺交易C2a/C2b，他们就需要使用(PAliceRSMC2,  PBobRSMC2)  来构建多重签名的RSMC输出。

After both parties know the output values from the Commitment Transactions, both parties create the pair of Commitment Transactions,
e.g. C2a/C2b, but do not exchange signatures for the Commitment Trans- actions. They both sign the Revocable Delivery transaction (RD2a/RD2b) and exchange the signatures. Bob signs RD1a and  gives  it  to  Alice  (using KBobRSMC2), while Alice signs RD1b and gives it to Bob (using KAliceRSM C2).

> 当双方就承诺交易的输出金额达成一致后，就可以创建像C2a/C2b这样一对承诺交易，但是创建时先不要交换签名。当创建对应的可撤销传送交易(RD2a/RD2b)并交换签名后，再为互相承诺交易签名。此时Bob使用KBobRSMC2  对RD1a签名并发送给Alice，同样的，Alice使用KAliceRSM C对RD1b签名并发送给Bob。

When both parties have the Revocable Delivery transaction, they ex-
change signatures for the Commitment Transactions. Bob signs C1a using KBobF  and gives it to Alice, and Alice signs C1b using  KAliceF  and gives it  to Bob.

> 当双方都拥有可撤销传送交易后，就可以交换对应的承诺交易的签名。Bob使用KBobF为C1a签名并发送给Alice，同样的，Alice使用KAliceF  为C1b签名并发送给Bob。

At this point, the prior Commitment Transaction as well as the new Commitment Transaction can be broadcast; both C1a/C1b and C2a/C2b are valid. (Note that Commitments older than the prior Commitment are invalidated via penalties.) In order to invalidate C1a and C1b, both parties exchange Breach Remedy Transaction (BR1a/BR1b) signatures for the prior commitment C1a/C1b. Alice sends BR1a to Bob  using  KAliceRSMC1,  and Bob sends BR1b to Alice using KBobRSMC1. When both Breach Remedy signatures have been exchanged, the channel state is now at the current Commitment C2a/C2b and the balances are now committed.

> 此时，之前的承诺交易以及新生成的承诺交易都可以广播；C1a/C1b以及C2a/C2b都是合法的(注意更早的承诺交易已经因为惩罚约束失效了)。为了让C1a/C1b失效，双方需要交换对应C1a/C1b的违约补偿交易(BR1a/BR1b)的签名。Alice使用KAliceRSMC1为BR1a签名并发送给Bob，Bob使用KBobRSMC1为BR1b签名并发送给Alice。当双方交换了违约补偿交易的签名后，通道状态变为承认C2a/C2b的资金分配。

However, instead of disclosing the BR1a/BR1b signatures, it’s also possible to just disclose the private keys to the counterparty. This is more effective as described later in the key storage section. One can disclose the private keys used in one’s own Commitment Transaction. For example, if Bob wishes to invalidate C1b, he sends his private keys used in C1b to Alice (he does NOT disclose his keys used in C1a, as that would permit coin theft). Similarly, Alice discloses all her private key outputs in C1a to Bob to invalidate C1a.

> 但是，与其公开BR1a/BR1b签名，还可以只向对手公开私钥。就像下面章节的密钥存储部分描述的，公开自己在承诺交易中使用的私钥更有效。例如，如果Bob希望使C1b失效，他将会把在C1b中使用的私钥发送给Alice(他不会公开在C1a中使用的私钥，因为这会导致资金被窃取)。类似的，Alice向Bob公开C1a中使用的私钥，让C1a失效。

If Bob incorrectly broadcasts C1b, then because Alice has all the private keys used in the outputs of C1b, she can take the money. However, only Bob is able to broadcast C1b. To prevent this coin theft risk, Bob should destroy all old Commitment Transactions.

> 如果Bob错误的广播C1b，那么因为Alice拥有C1b所有输出使用的私钥，她就可以提取资金。然后，只有Bob才能广播C1b。为了防止资金被窃取的风险，Bob应该销毁所有旧的承诺交易。

### 3.4 Cooperatively Closing Out a Channel

### 3.4 协作关闭一个支付通道

Both parties are able to send as many payments to their counterparty as they wish, as long as they have funds available in the channel, knowing that in the event of disagreements they can broadcast to the blockchain the current state at any time.

> 双方都可以根据自己的意愿向对方发送尽可能多的款项，只要他们在频道中有可用资金。并且双方都明白，一旦出现分歧，他们随时可以向区块链广播当前状态。

In the vast majority of cases, all the outputs from the Funding Trans- action will never be broadcast on the blockchain. They are just there in case the other party is non-cooperative, much like how a contract is rarely enforced in the courts. A proven ability for the contract to be enforced in a deterministic manner is sufficient incentive for both parties to act honestly.

> 在绝大多数情况下，所有花费保证金交易输出的交易都不会在区块链上广播。它们只是用来防止另一方不合作，就像合同很少在法庭上强制执行一样。保证合同以确定性的方式执行足以激励双方诚实行事。

When either party wishes to close out a channel cooperatively, they will be able to do so by  contacting the other party and spending from    the Funding Transaction with an output of the most current Commitment Transaction directly with no script encumbering conditions. No further pay- ments may occur in the channel.

> 当任何一方希望通过协作关闭一个支付通道时，他们可以这样做，通过与对方协作广播最近的承诺交易花费保证金交易的输出，这笔交易不受任何脚本的阻碍。之后该通道内就不会构造其它任何支付交易了。

![Figure10](figures/figure10.png?raw=true "Figure10")

Figure 10:  If both counterparties are cooperative,  they take the balances in the cur-  rent Commitment Transaction and spend from the Funding Transaction with a Exercise Settlement Transaction (ES). If the most recent Commitment Transaction gets broadcast instead, the payout (less fees) will be the same.

> 图10:如果交易双方是合作的，他们将当前承诺交易中的金额作为保证金交易的最终花费，构造一笔结算交易直接广播。这跟广播最后的承诺交易效果是相同的，而且可以节省交易费用。

The purpose of closing out cooperatively is to reduce the number   of transactions that occur on the blockchain and both parties will be able to receive their funds immediately (instead of one party waiting for the Revocation Delivery transaction to become valid).

> 合作结算的目的是减少区块链上广播的交易数量，双方将能够立即收到他们的资金(而不用一方等待可撤销传送交易失效)。

Channels may remain in perpetuity until they decide to cooperatively close out the transaction, or when one party does not cooperate with another and the channel gets closed out and enforced on the blockchain.

> 支付通道可以一直保持，直到双方决定协作完成交易，或者一方不与另一方合作关闭通道，并最终在区块链上强制结算。

### 3.5 Bidirectional Channel Implications and Summary

### 3.5 双向支付通道的启示和总结

By ensuring channels can update only with the consent of both parties, it is possible to construct channels which perpetually exist in the blockchain. Both parties can update the balance inside the channel with whatever output balances they wish, so long as it’s equal or less than the total funds commit- ted inside the Funding Transaction; balances can move in both directions. If one party becomes malicious, either party may immediately close out the channel and broadcast the most current state to the blockchain. By using a fidelity bond construction (Revocable Delivery Transactions), if a party violates the terms of the channel, the funds will be sent to the counterparty, provided the proof of violation (Breach Remedy Transaction) is entered into the blockchain in a timely manner. If both parties are cooperative, the chan- nel can remain open indefinitely, possibly for many years.

> 通过确保支付通道只能在双方同意的情况下更新，就有可能构建永远存在于区块链中的通道。双方可以用任何他们希望的输出余额来更新通道内的资金分配，只要总输出等于或小于保证金交易的总输出；资金可以双向流动。如果一方有恶意行动，任何一方都可以立即关闭支付通道并向区块链广播最新状态。利用可撤销传送交易，如果一方违反了通道条款，违约证明(违约补偿交易)就可以广播到区块链中，资金就会被发送给交易对手方。如果双方都愿意合作，通道可以无限期开放，甚至可以开放很多年。

This type of construction is only possible because adjudication occurs programatically over the blockchain as part of the Bitcoin consensus, so one does not need to trust the other party. As a result, one’s channel counterparty does not possess full custody or control of the funds.

> 建造这种支付通道是可能的，因为通过区块链证明这一切的合约作为比特币共识一部分执行，所以不需要信任另一方。同时，通道对手方并不拥有资金的完全托管或控制权。
